#!/bin/bash

SCRIPTDIR=$(dirname $0)

show_commands()
{
  echo "Usage: $0 <command>"
  echo " "
  echo "Commands:"
  echo "status  [server-dir]        "
  echo "start   [server-dir]        "
  echo "stop    [server-dir]        "
  echo "restart [server-dir]        "
  echo " "
  echo "pull    <env> <tag> <server-dir>        "
  echo "push    <env> <tag>        "
  echo " "
  echo "remote-status   <env>"
  echo "remote-start    <env>"
  echo "remote-stop     <env>"
  echo "remote-restart  <env>"
  echo " "
  exit
}

#
# ---------------- Settings ------------------
#
CVS_DIR="analytics/bursts"
CVS_BIN_DIR="bin"
CVS_BIN_FILENAME="algoctl"
CVS_CONF_DIR="config"
CVS_CONF_FILENAME="burstsAlgo.conf"

DEPLOY_BIN_DIR="bin"
DEPLOY_BIN_FILENAME="algoctl"
DEPLOY_CONF_DIR="config"
DEPLOY_CONF_FILENAME="burstsAlgo.conf"
DEPLOY_OUTPUT_DIR="var"
DEPLOY_OUTPUT_PID_FILENAME="burstsAlgo.pid"
DEPLOY_OUTPUT_STDERR_FILENAME="stderr.log"
DEPLOY_OUTPUT_STDOUT_FILENAME="stdout.log"
DEPLOY_SERVER_DIR="src/analytics/bursts"
DEPLOY_SRC_DIR="src"

PROLOG_LOAD_FILE="src/prolog/load.pro"

#
# ---------------- Commands ------------------
#

run_status()
{
  local dir="${1:-$SCRIPTDIR}"
  
  pid=$(read_pid_for_dir "$dir")
  if [ $(get_status_for_pid "$pid") -eq 0 ]; then
    port=$(get_port_for_pid "$pid")
    echo "Bursts algorithm server is running on port $port."
  else
    echo "Bursts algorithm server is stopped."
  fi
}

run_start()
{
  local dir="${1:-$SCRIPTDIR}"

  read_conf_for_dir "$dir"

  echo "Starting"
  # Write pid
  write_pid_to_dir "$dir" "$$"
  
  # Launch
  cd "$dir/$DEPLOY_SERVER_DIR"
  exec $PROLOG \
    -f "$PROLOG_LOAD_FILE" \
    -g "server($PORT)" \
    -t 'repeat,sleep(99),fail.'
}

run_stop()
{
  local dir="${1:-$SCRIPTDIR}"
  
  status=$()
}

run_restart()
{
  local dir="${1:-$SCRIPTDIR}"
  echo "Restarting"
}

run_pull()
{
  local env="$1"
  local tag="$2"
  local dir="$3"

  echo "Pulling"

  # Create directories
  mkdir -p "$dir"
  mkdir -p "$dir/$DEPLOY_BIN_DIR"
  mkdir -p "$dir/$DEPLOY_CONF_DIR"
  mkdir -p "$dir/$DEPLOY_SRC_DIR"
  mkdir -p "$dir/$DEPLOY_OUTPUT_DIR"

  # Pull down source
  cd "$dir/$DEPLOY_SRC_DIR"
  cvs export -r "$tag" "$CVS_DIR"

  # Copy appropriate config file
  cp "$dir/$DEPLOY_SRC_DIR/$CVS_DIR/$CVS_CONF_DIR/$env/$CVS_CONF_FILENAME" \
     "$dir/$DEPLOY_CONF_DIR/$DEPLOY_CONF_FILENAME"

  # Copy control script
  cp "$dir/$DEPLOY_SRC_DIR/$CVS_DIR/$CVS_BIN_DIR/$CVS_BIN_FILENAME" \
     "$dir/$DEPLOY_BIN_DIR/$DEPLOY_BIN_FILENAME"  
}

run_push()
{
  local env="$1"
  loval tag="$2"
  
  tmpdir=$(mktemp -d "/tmp/bursts-algo-push-$env-$tag-XXXX")

  run_pull "$env" "$tag" "$tmpdir"  
  dest=$(get_destpath_for_env "$env")
  run_remote_stop "$env"
  push_to "$tmpdir" "$dest"
  run_remote_start "$env"
}

run_remote_status()
{
  local env="$1"
  read_conf_for_env "$env"
  
  ssh "${REMOTE_USER}@${REMOTE_HOST}" \
  "$DEPLOYMENT_DIR/$DEPLOY_BIN_DIR/$DEPLOY_BIN_FILENAME" \
  status
}

run_remote_start()
{
  local env="$1"
  read_conf_for_env "$env"

  ssh "${REMOTE_USER}@${REMOTE_HOST}" \
  "$DEPLOYMENT_DIR/$DEPLOY_BIN_DIR/$DEPLOY_BIN_FILENAME" \
  start
}

run_remote_stop()
{
  local env="$1"
  read_conf_for_env "$env"

  ssh "${REMOTE_USER}@${REMOTE_HOST}" \
  "$DEPLOYMENT_DIR/$DEPLOY_BIN_DIR/$DEPLOY_BIN_FILENAME" \
  stop
}

run_remote_restart()
{
  local env="$1"
  read_conf_for_env "$env"

  ssh "${REMOTE_USER}@${REMOTE_HOST}" \
  "$DEPLOYMENT_DIR/$DEPLOY_BIN_DIR/$DEPLOY_BIN_FILENAME" \
  restart
}

#
# ---------------- Utilities ------------------
#

get_status_for_dir()
{
  local dir="$1"
  
  echo $(get_status_for_pid)
}

get_status_for_pid()
{
  local pid="$1"
  kill -0 "$pid" 2>/dev/null
  echo $?
}

get_port_for_pid()
{
  local pid="$1"
  netstat --listening --programs --numeric -t 2>/dev/null \
  | perl -ne "if (m/\S+\s+\S+\s+\S+\s+(?:[\d\.]+):($pid)\s+\S+\s+\S+\s+(\d+)\/(\S+)/) "'{ print $1 }'
}

get_pid_for_dir()
{
  local dir="$1"
  local pidfile="$dir/$DEPLOY_OUTPUT_DIR/$DEPLOY_OUTPUT_PID_FILENAME"
  echo $(read_pid_from_file "$pidfile")
}

write_pid_to_dir()
{
  local dir="$1"
  local pid="$2"
  local pidfile="$dir/$DEPLOY_OUTPUT_DIR/$DEPLOY_OUTPUT_PID_FILENAME"
  write_pid_to_file "$pidfile" "$pid"
}

read_pid_from_file()
{
  local filename="$1"
  $(cat "$filename" 2>/dev/null)
}

write_pid_to_file()
{
  local filename="$1"
  local pid="$2"
  echo "$pid" > "$filename"
}

push_to()
{
  local srcpath="$1"
  local destpath="$2"
  
  echo "Copying to remote host..."
  rsync --partial --progress --rsh=ssh --archive "$srcpath" "$destpath"
}

read_conf_for_dir()
{
  local dir="$1"
  local conf="$dir/$DEPLOY_CONF_DIR/$DEPLOY_CONF_FILENAME"
  source "$conf"
}

read_conf_for_env()
{
  local env="$1"
  local conf="$DEPLOY_SRC_DIR/$CVS_DIR/$CVS_CONF_DIR/$env/$CVS_CONF_FILENAME"
  source "$conf"
}

get_destpath_for_env()
{
  local env="$1"
  read_config_for_env "$env"
  echo "${REMOTE_USER}@${REMOTE_HOST}:$DEPLOYMENT_DIR"
}




#
# ---------------- Main ------------------
#


command="$1"
shift

if [ -z "$command" ]; then
  show_commands
fi

case $command in
  status)
  run_remote_status $@
  ;;
  start)
  run_start $@
  ;;
  stop)
  run_stop $@
  ;;
  restart)
  run_restart $@
  ;;
  pull)
  run_pull $@
  ;;
  push)
  run_push $@
  ;;
  remote-status)
  run_remote_status $@
  ;;
  remote-start)
  run_remote_start $@
  ;;
  remote-stop)
  run_remote_stop $@
  ;;
  remote-restart)
  run_remote_restart $@
  ;;
  *)
  show_commands
  ;;
esac



